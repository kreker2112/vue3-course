VUE (Фреймворк):

Концепции:

1 -- VirtualDom --:
        Самая важная концепция это Virtual Dom. После парсинга HTML Страницы браузер строит DOM-дерево и каждая операция
    с DOM-деревом это крайне ресурсоемкая сложная задача. И чтобы оптимизировать процессы ререндеринга страницы, Vue под капотом строит, так
    называемое, Виртуальное DOM-дерево. И если говорить совсем кратко, Vue накапливает количество изменений, которые необходимо отобразить на странице,
    после чего сравнивает оригинальную версию DOM-дерева страницы и нашу виртуальную копию, и сразу всей пачкой все изменения применяются к DOM-дереву,
    после чего мы видим обновленную страницу с новыми данными

2 -- Компонентный подход --:
        Vue пропагандирует компонентный подход:
    Все приложение делится на маленькие, большие и переиспользуемые куски (компоненты). Разрабатывая каждый компонент важно помнить, что зачастую они
    являются переиспользуемыми, то есть, у нас в приложении есть пять страниц и в каждую из них мы можем вставить компонент со списком пользователей,
    и все от чего он зависит, это от входных параметров, то есть в этот компонент мы передали какой-то массив с объектами, где каждый объект представляет
    из себя описание пользователя, и все, мы должны быть уверенными, что этот компонент отрисует нам список.

            При компонентном подходе у Дом-дерева всегда один узел, это самый корневой родительский компонент, который чаще всего называется App.vue.
        В этот компонент помещаются другие компоненты (к примеру: большие компоненты: Навигационное меню Menu.vue и список пользователей UserList.vue,
        в свою очередь Навигационное меню Menu.vue и список пользователей UserList.vue содержат внутри себя меньшие компоненты: В Навигационном меню
        это шапка меню MenuHeader.vue и отдельный элемент меню MenuItem.vue, а список пользователей UserList.vue состоит из какого-то количества
        пользователей UserItem.vue)

3 -- Реактивность --:
        К примеру, для работы без фреймворка, со счетчиком по клику на кнопке, для взаимодействия HTML элемента и интерактива с кликом, чтобы были видны
    изменения данных на странице по клику, необходимо ссылку на блок с аутпутом, в котором отображена переменная счетчика, поместить внуть слушателя событий.
    То есть, данные, с которыми мы работаем и графическое представление никак не связаны, и приходится руками брать счетчик и подставлять в необходмый
    для нас блок.

        При реализации такого же функционала при помощи Vue, мы объявляем внутри компонента переменную:

        data() {
            return {
                likes: 0
            }
        }

        , в которую будет записываться результат счетчика
    (Во Vue подобные значения называются моделями) и внутри этого же компонента есть шаблон разметки:

    <div>Кол-во лайков = {{ likes }}</div>
    <button @click="likes += 1">Поставить лайк</button>

    в который встраиваем модель переменной, вешаем слушатель
    события на кнопку и просто инкрементируем каждое значение счетчика по нажатию на кнопку.

    То есть при реактивности у программиста упор идет больше на работу с данными, нежели с тем, как синхрониховать эти данные с нашей страницей

        Как работает реактивность:
    Внутри компонента мы объявили некоторую модель, которая по дефолту равняется 0 (кол-во лайков).
    Далее невидимым для нас образом Vue под капотом оборачивает каждую модель в обычный JavaScript-овый Proxy, который позволяет установить некоторые ловушки
    на объект, например, одна из ловушек может отрабатывать, когда объект был изменен, так вот Vue оборачивает модель в Proxy и добавляет ловушки на геттеры
    и сеттеры, то етсь на изменение и получение объекта, и вот как раз в тот момент, когда мы пытаемся изменить ту, или иную модель, срабатывает ловушка set(),
    которая срабатывает в тот момент, когда мы изменили значение и Vue вызывает render функцию для обновления интерфейса на экране с новыми данными

                                                Реактивность

                                               ________ model
                                              |
                                              |
            data() {                          |
                return {                      |
                    likes: 0 _________________|____
                    }                              |
                }                                  |
                                                   |
                                                    new Proxy (likes, {
                                                      get() {}
                                                      Set() {
                                                         render();
                                                      }cd
                                                    })

    Это удобно, поскольку мы сосредотачиваемся на логике работы с данными (мы каким-то образом, невожно каким, изменили значение счетчика, и мы можем
    быть уверенны, что интерфейс у нас обновится)

4 -- Создание проекта --:
    Сначала установить yarn global add @vue/cli
    Создать проект: vue create vue3-course
    Настроить Проект: vue create .
    Запустить проект: yarn serve
     -- Все настройки проекта хранятся в файле vue.config.js (который создается автоматически при создании проекта)
     -- В нем можно настроить пути к папкам, в которых хранятся компоненты, стили, картинки и т.д. (по умолчанию все
        компоненты хранятся в папке src/components)

     -- Все компоненты в проекте должны иметь расширение .vue (которое означает, что это Vue-компонент)

     -- Все компоненты в проекте должны иметь три секции:
        1 -- template --: в которой хранится разметка компонента
        2 -- script --: в которой хранится логика компонента
        3 -- style --: в которой хранится стили компонента

    -- Все компоненты в проекте должны иметь один корневой элемент (который оборачивает весь компонент)

    -- Все компоненты в проекте должны иметь уникальное имя (которое должно начинаться с большой буквы)

5 -- Двустороннее связывание--:

    Задача дустороннего связывания это связать модель и шаблон, то есть, когда мы меняем данные в модели, они автоматически меняются в шаблоне,

    Двустороннее связывание это когда мы можем изменять данные в модели и они автоматически будут меняться в шаблоне,
    и наоборот, когда мы изменяем данные в шаблоне, они автоматически меняются в модели.

    К примеру, у нас есть модель, которая хранит в себе некоторое значение, и в шаблоне мы хотим отобразить это значение,
    и при этом мы хотим, чтобы при изменении значения в шаблоне, оно автоматически менялось в модели, и наоборот,
    когда мы меняем значение в модели, оно автоматически менялось в шаблоне.

    Для этого в Vue есть директива v-model, которая позволяет нам связать модель и шаблон.

    Для того, чтобы связать модель и шаблон, необходимо в шаблоне в элементе, в котором мы хотим отобразить значение модели,
    добавить директиву v-model и в качестве аргумента передать название модели, которую мы хотим связать с этим элементом.

    К примеру, у нас есть модель, которая хранит в себе значение likes, и в шаблоне мы хотим отобразить это значение,
    и при этом мы хотим, чтобы при изменении значения в шаблоне, оно автоматически менялось в модели, и наоборот,
    когда мы меняем значение в модели, оно автоматически менялось в шаблоне.

    Для этого в шаблоне в элементе, в котором мы хотим отобразить значение модели, добавляем директиву v-model и в качестве аргумента
    передаем название модели, которую мы хотим связать с этим элементом.

    <div>Кол-во лайков = {{ likes }}</div>
    <button @click="likes += 1">Поставить лайк</button>
    <input type="text" v-model="likes">

             Двустороннее связывание (таблица событий и атрибутов)
    ___________________________________________________________
   |                |                    |                     |
   |    Элемент     |      Событие       |        Атрибут      |
   |________________|____________________|_____________________|
   |  - input       |                    |                     |
   |  - textarea    |      oninput       |        VALUE        |
   |________________|____________________|_____________________|
   |  -checkbox     |                    |                     |
   |  -radio btn    |      onchange      |        CHECKED      |
   |________________|____________________|_____________________|
   |                |                    |                     |
   |  -списки       |      onchange      |         VALUE       |
   |________________|____________________|_____________________|

   Инпут, чекбоксы и списки встечаются часто, поэтому для них есть сокращенная запись:
   (v-model="likes" вместо v-bind:value="likes" и v-on:input="likes = $event.target.value" вместо @input="likes = $event.target.value")

6 -- Директивы --:
    Директивы это специальные атрибуты, которые позволяют нам добавлять некоторую логику в шаблон.

    Директивы в Vue начинаются с префикса v- (v-model, v-if, v-show, v-for, v-on, v-bind, v-text, v-html, v-pre, v-cloak, v-once, v-slot, v-is)

     -- Директива v-model позволяет нам связать модель и шаблон (обеспечить двустороннее связывание).

            Пример использования директивы v-model:
            <input type="text" v-model="likes">

     -- Директива v-show добавляет в шаблон элемент, если условие истинно, и удаляет элемент из шаблона, если условие ложно.

            Пример использования директивы v-show:
            <div v-show="likes > 0">Кол-во лайков = {{ likes }}</div>

     -- Директива v-if позволяет нам добавлять условную логику в шаблон (в зависимости от условия элемент будет отображаться или нет) (в отличии от v-show,
    который просто скрывает элемент, но он все равно есть в DOM-дереве, v-if удаляет элемент из DOM-дерева, если условие ложно).

            Для того, чтобы добавить условную логику в шаблон, необходимо в элементе, в котором мы хотим добавить условную логику,
            добавить директиву v-if и в качестве аргумента передать название модели, которая будет хранить в себе условие,
            по которому будет происходить отображение элемента.

            Пример использования директивы v-if:
            <div v-if="likes > 0">Кол-во лайков = {{ likes }}</div>
            <button @click="likes += 1">Поставить лайк</button>

     -- Директива v-for позволяет нам добавлять циклы в шаблон (в зависимости от кол-ва элементов в массиве, в шаблоне будет отображаться соответствующее
    кол-во элементов).

            Пример использования директивы v-for:
            <div v-for="post in posts" :key="post.id">
                <h1>{{ post.title }}</h1>
                <p>{{ post.text }}</p>

     -- Директива v-on позволяет нам добавлять обработчики событий в шаблон (в зависимости от события, будет выполняться определенная логика).
            Чаще всего используется его сокращенный вариант @ (к примеру, @click="likes += 1").

            Пример использования директивы v-on:
            <button @click="likes += 1">Поставить лайк</button>

     -- Директива v-bind позволяет нам добавлять атрибуты в шаблон.
            Сокращенная запись v-bind: : (к примеру, :src="image").

            Пример использования директивы v-bind:
            <img v-bind:src="image" alt="">

     -- Директива v-text позволяет нам добавлять текстовый контент в шаблон (вместо двойных фигурных скобок {{}}).

            Пример использования директивы v-text:
            <div v-text="likes"></div>

     -- Директива v-html позволяет нам добавлять HTML контент в шаблон (вместо двойных фигурных скобок {{}}).

            Пример использования директивы v-html:
            <div v-html="likes"></div>

     -- Директива v-pre позволяет нам отключить компиляцию шаблона
            (все директивы и интерполяции внутри элемента с директивой v-pre будут отображаться как есть).

            Пример использования директивы v-pre:
            <div v-pre>{{ likes }}</div>

     -- Директива v-cloak позволяет нам скрыть незакомпилированный шаблон (все элементы с директивой v-cloak будут скрыты до момента компиляции шаблона).

            Пример использования директивы v-cloak:
            <div v-cloak>{{ likes }}</div>

     -- Директива v-once позволяет нам отрисовать шаблон только один раз (при изменении данных в шаблоне, шаблон не будет перерисовываться).

            Пример использования директивы v-once:
            <div v-once>{{ likes }}</div>

     -- Директива v-slot позволяет нам передавать контент в слоты (для того, чтобы передать контент в слот, необходимо в элементе, в котором мы хотим
    передать контент в слот, добавить директиву v-slot и в качестве аргумента передать название слота).

            Пример использования директивы v-slot:
            <template v-slot:header>
                <h1>Заголовок</h1>
            </template>

     -- Директива v-is позволяет нам динамически выбирать компоненты (для того, чтобы использовать директиву v-is, необходимо в элементе, в котором мы хотим
    использовать директиву v-is, добавить директиву v-is и в качестве аргумента передать название компонента, который мы хотим использовать).

            Пример использования директивы v-is:
            <div v-is="component"></div>

     -- Директива v-show позволяет нам добавлять условную логику в шаблон.

            Для того, чтобы добавить условную логику в шаблон, необходимо в элементе, в котором мы хотим добавить условную логику,
            добавить директиву v-show и в качестве аргумента передать название модели, которая будет хранить в себе условие,
            по которому будет происходить отображение элемента.

            <div v-show="likes > 0">Кол-во лайков = {{ likes }}</div>

7 -- Пропсы --:
    Пропсы это входные параметры, которые передаются в дочерний компонент из родительского.
    Пропсы нельзя изменять в дочернем компоненте, они только для чтения, а изменяться
    они должны в родительском компоненте, а дочерний компонент должен получать их уже в измененном виде. Сам он их изменять не может.

    Для того, чтобы передать пропсы в дочерний компонент, необходимо в теге дочернего компонента добавить атрибут
    v-bind:имя_пропса="значение_пропса". Имя пропса должно быть в camelCase нотации. В качестве значения пропса
    может быть какая-то переменная, так и просто строка. В дочернем компоненте пропсы доступны в объекте props.

    <template>
        <div>
            <h1>{{ title }}</h1>
            <p>{{ text }}</p>
        </div>
    </template>

    <script>
        export default {
            name: 'Post',
            props: {
                title: {
                    type: String,
                    required: true
                },
                text: {
                    type: String,
                    required: true
                }
            }
        }
    </script>

    <style scoped>
        h1 {
            color: red;
        }
    </style>

    В примере выше мы передаем в дочерний компонент Post два пропса: title и text. В шаблоне дочернего компонента мы
    выводим эти пропсы в разметку. В скрипте дочернего компонента мы объявляем объект props, в котором мы указываем
    название пропса и его тип. Также мы можем указать, является ли пропс обязательным или нет. Если пропс обязательный,
    то в случае, если он не будет передан в дочерний компонент, то в консоли будет выведена ошибка. Если пропс не
    обязательный, то в случае, если он не будет передан в дочерний компонент, то в консоли ошибки не будет.

8 -- Взаимодействие дочернего компонента и родительского --:



                                __________________________
                               |                          |_______________  @create="createPost"
                               |         Родитель         |               | подписывается на событие так же, как и на input, click и т.д.
                               |__________________________|               | Эти нативные события аргументом принимают объект события (ивент)
                               |                                          | И если мы подпишемся на событие @create, аргументом мы будем
                        Список | Props                                    | принимать событие CREATE(POST), которое мы сгенерировали в дочернем
                        постов |                                          | компоненте.
                               |                                          | Для подписки на событие в родительском компоненте используется
                             _\|/____________________________             | функция $emit, которая принимает два параметра: название события и
                            |                                |            | данные, которые мы хотим передать в родительский компонент
                            |                                |           \|/
                            |                                |    генерируем событие
                            |            Ребенок             |       CREATE(POST) (это идентично событию click, change и т.д.)
                            |                                |
                            |________________________________|

9 -- Декомпозиция --:

        Декомпозиция - это разбиение большой задачи на маленькие подзадачи, которые легче решить, или разбиение большого компонента на маленькие 
    компоненты, которые легче поддерживать и переиспользовать.

        Основное правило декомпозиции: каждый компонент должен быть независимым и не должен знать о внешнем мире. Чем слабо связанные компоненты
    будут делаться, тем масштабируемее будет приложение.

        К примеру, у нас есть компонент, который отвечает за отображение списка постов, и в этом компоненте мы хотим отобразить список постов, и
    для этого мы создаем дочерний компонент Post, который будет отвечать за отображение одного поста. И в этом дочернем компоненте мы хотим отобразить
    заголовок и текст поста, и для этого мы создаем дочерний компонент PostTitle, который будет отвечать за отображение заголовка поста, и дочерний
    компонент PostText, который будет отвечать за отображение текста поста.

        Таким образом, мы разбили большой компонент на маленькие компоненты, которые легче поддерживать и переиспользовать. Также мы соблюдаем
    основное правило декомпозиции: каждый компонент должен быть независимым и не должен знать о внешнем мире.

10 -- Слоты --:

        Слоты - это специальные элементы, которые позволяют нам передавать контент в дочерний компонент из родительского.
    Их синтаксис выглядит так: <slot></slot>. Все, что будет находиться между тегами <slot></slot> в родительском компоненте,
    будет передано в дочерний компонент.
        Если не использовать название для слота, то все, что будет находиться между тегами <slot></slot> в родительском компоненте,
    будет передано в дочерний компонент в слот по умолчанию. Если использовать название для слота, то все, что будет находиться между
    тегами <slot name="название_слота"></slot> в родительском компоненте, будет передано в дочерний компонент в слот с указанным названием.
        В дочернем компоненте слоты доступны в объекте $slots. В объекте $slots хранятся все слоты, которые были переданы в дочерний компонент.
    Если слот не был передан в дочерний компонент, то в объекте $slots будет пустой массив. Если слот был передан в дочерний компонент,
    то в объекте $slots будет массив, в котором будут храниться все переданные в дочерний компонент слоты.

11 -- modelValue --:

        modelValue - это входной параметр, который позволяет нам передавать в дочерний компонент значение модели. В дочернем компоненте мы можем
    изменять это значение, но мы не можем изменять значение модели в родительском компоненте. Если мы хотим изменить значение модели в родительском
    компоненте, то мы должны использовать событие update:modelValue. В дочернем компоненте мы должны вызвать событие update:modelValue и передать
    в него новое значение модели. В родительском компоненте мы должны подписаться на событие update:modelValue и в качестве аргумента принять новое
    значение модели.

        В примере ниже мы передаем в дочерний компонент Post значение модели post, и в дочернем компоненте мы можем изменять это значение, но мы не
    можем изменять значение модели post в родительском компоненте. Если мы хотим изменить значение модели post в родительском компоненте, то мы должны
    использовать событие update:modelValue. В дочернем компоненте мы должны вызвать событие update:modelValue и передать в него новое значение модели.
    В родительском компоненте мы должны подписаться на событие update:modelValue и в качестве аргумента принять новое значение модели.

    <template>
        <div>
            <h1>{{ post.title }}</h1>
            <p>{{ post.text }}</p>
            <button @click="updatePost">Обновить пост</button>
        </div>
    </template>

    <script>
        export default {
            name: 'Post',
            props: {
                modelValue: {
                    type: Object,
                    required: true
                }
            },
            data() {
                return {
                    post: this.modelValue
                }
            },
            methods: {
                updatePost() {
                    this.post.title = 'Новый заголовок'
                    this.post.text = 'Новый текст'
                    this.$emit('update:modelValue', this.post)
                }
            }
        }
    </script>

    <style scoped>
        h1 {
            color: red;
        }
    </style>

12 -- Модификаторы --:

    Модификаторы - это специальные атрибуты, которые позволяют нам добавлять некоторую логику к директивам. Модификаторы начинаются с точки и могут чейниться
    (то есть, мы можем использовать несколько модификаторов для одной директивы).

     - Список модификаторов событий @[event]: .stop, .prevent, .capture, .self, .once, .passive, .native

        Рассмотрим каждый из них подробнее:

    .stop - останавливает всплытие события (то есть, если у нас есть вложенные элементы, и мы кликнули на внутренний элемент, то событие не будет
    всплывать на родительские элементы). Этот модификатор используется для того, чтобы остановить всплытие события.

    Пример использования модификатора .stop:
    <div @click="clickHandler">
        <div @click.stop="clickHandler"></div>

    .prevent - отменяет действие по умолчанию (то есть, если у нас есть ссылка, и мы кликнули по ней, то событие не будет переходить по ссылке). Этот
    модификатор используется для того, чтобы отменить действие по умолчанию.

    Пример использования модификатора .prevent:

    .capture - событие будет срабатывать на фазе захвата (то есть, если у нас есть вложенные элементы, и мы кликнули на внутренний элемент, то событие
    будет срабатывать сначала на внешнем элементе, а потом на внутреннем). Этот модификатор используется для того, чтобы событие срабатывало на фазе
    захвата.
        Фаза захвата - это первая фаза жизненного цикла события. В этой фазе событие сначала срабатывает на внешнем элементе, а потом на внутреннем.

    Пример использования модификатора .capture:
    <template>
    <div @click.capture="clickHandler">
        <div @click="clickHandler"></div>
    </div>
    </template>

    <script>
    export default {
        methods: {
            clickHandler() {
                console.log('click')
            }
        }
    }
    </script>

        В этом случае сначала сработает событие на внешнем элементе, а потом на внутреннем. Если мы уберем модификатор .capture, то сначала сработает событие
    на внутреннем элементе, а потом на внешнем. Это происходит потому, что по умолчанию событие срабатывает на фазе всплытия. Если мы хотим, чтобы
    событие срабатывало на фазе захвата, то мы должны использовать модификатор .capture.




    .self - событие будет срабатывать только на элементе, на котором оно было вызвано (то есть, если у нас есть вложенные элементы, и мы кликнули на
    внутренний элемент, то событие будет срабатывать только на внутреннем элементе).

    Пример использования модификатора .self:
    <template>
    <div @click="clickHandler">
        <div @click.self="clickHandler"></div>
    </div>
    </template>

    <script>
    export default {
        methods: {
            clickHandler() {
                console.log('click')
            }
        }
    }
    </script>

        В этом случае событие будет срабатывать только на внутреннем элементе. Если мы уберем модификатор .self, то событие будет срабатывать на внешнем
    элементе и на внутреннем элементе. Это происходит потому, что по умолчанию событие срабатывает на фазе всплытия. Если мы хотим, чтобы событие
    срабатывало только на элементе, на котором оно было вызвано, то мы должны использовать модификатор .self.

    .once - событие будет срабатывать только один раз (то есть, если у нас есть вложенные элементы, и мы кликнули на внутренний элемент, то событие
    будет срабатывать только один раз).

    Пример использования модификатора .once:
    <template>
    <div @click.once="clickHandler">
        <div @click="clickHandler"></div>
    </div>
    </template>

    <script>
    export default {
        methods: {
            clickHandler() {
                console.log('click')
            }
        }
    }
    </script>

        В этом случае событие будет срабатывать только один раз. Если мы уберем модификатор .once, то событие будет срабатывать каждый раз, когда мы
    кликаем на элемент. Это происходит потому, что по умолчанию событие срабатывает каждый раз, когда мы кликаем на элемент. Если мы хотим, чтобы
    событие срабатывало только один раз, то мы должны использовать модификатор .once.

    .passive - событие будет срабатывать в режиме пассивного слушателя (то есть, если у нас есть вложенные элементы, и мы кликнули на внутренний
    элемент, то событие будет срабатывать в режиме пассивного слушателя). Этот модификатор используется для улучшения производительности.
        Пассивный слушатель - это слушатель, который не вызывает метод preventDefault(). Это позволяет браузеру оптимизировать обработку события.

    Пример использования модификатора .passive:
    <template>
    <div @click.passive="clickHandler">
        <div @click="clickHandler"></div>
    </div>
    </template>

    <script>
    export default {
        methods: {
            clickHandler() {
                console.log('click')
            }
        }
    }
    </script>

        В этом случае событие будет срабатывать в режиме пассивного слушателя. Если мы уберем модификатор .passive, то событие будет срабатывать в
    режиме активного слушателя. Это происходит потому, что по умолчанию событие срабатывает в режиме активного слушателя. Если мы хотим, чтобы событие
    срабатывало в режиме пассивного слушателя, то мы должны использовать модификатор .passive.


    .native - событие будет срабатывать на нативном элементе (то есть, если у нас есть вложенные элементы, и мы кликнули на внутренний элемент, то
    событие будет срабатывать только на внешнем элементе). Этот модификатор используется для того, чтобы событие срабатывало на нативном элементе,
    а не на компоненте. Это может быть полезно, если мы хотим использовать модификаторы событий на компоненте, который не имеет нативного аналога.
    Например, если мы хотим использовать модификатор .prevent на компоненте, который не имеет нативного аналога, то мы можем использовать модификатор
    .native, чтобы событие срабатывало на нативном элементе, а не на компоненте.
        Нативный элемент - это элемент, который не является компонентом.
    Он может быть обычным HTML элементом или элементом из другой библиотеки. Например, если мы хотим использовать модификатор .prevent на компоненте
    v-btn, то мы можем использовать модификатор .native, чтобы событие срабатывало на нативном элементе button, а не на компоненте v-btn.

     - Список модификаторов директивы v-bind: .prop, .camel, .sync

        Рассмотрим каждый из них подробнее:

        .prop - привязывает значение к свойству элемента (то есть, если у нас есть элемент input, и мы хотим привязать значение к свойству value, то мы
    можем использовать модификатор .prop).
        Свойства элемента: value, checked, selected, disabled, readonly, required, open, min, max, step, tabIndex, type, name, list, pattern, width,
    height, size, accept, alt, autocomplete, dirname, form, formaction, formenctype, formmethod, formnovalidate, formtarget, inputmode, multiple,
    placeholder, results, spellcheck, src, srcdoc, srclang, srcset, usemap, wrap, ismap, download, href, hreflang, media, ping, referrerpolicy,
    rel, target, type, as, crossorigin, integrity, referrerpolicy, sizes, color, face, size, align, noshade, noresize, span, compact, start, reversed,
    type, value, label, default, kind, src, srclang, label, default.

    Пример использования модификатора .prop:
    <input type="text" v-bind:value.prop="likes"> или <input type="text" :value.prop="likes">

    Пример использования модификатора .prop с динамическим названием свойства:
    <input type="text" v-bind:[prop]="likes"> или <input type="text" :[prop]="likes">

        .camel - привязывает значение к свойству элемента в camelCase нотации (то есть, если у нас есть элемент input, и мы хотим привязать значение к
    свойству value в camelCase нотации, то мы можем использовать модификатор .camel).

    Пример использования модификатора .camel:
    <input type="text" v-bind:value.camel="likes"> или

    Пример использования модификатора .camel с динамическим названием свойства:
    <input type="text" v-bind:[prop].camel="likes"> или <input type="text" :[prop].camel="likes">

        .sync - привязывает значение к свойству элемента и добавляет событие update (то есть, если у нас есть элемент input, и мы хотим привязать значение
    к свойству value и добавить событие update, то мы можем использовать модификатор .sync).
        Событие update - это событие, которое срабатывает при изменении значения свойства элемента. Это событие позволяет нам изменять значение
    свойства элемента в родительском компоненте. Если мы хотим изменить значение свойства элемента в родительском компоненте, то мы должны использовать
    событие update. В дочернем компоненте мы должны вызвать событие update и передать в него новое значение свойства элемента. В родительском компоненте
    мы должны подписаться на событие update и в качестве аргумента принять новое значение свойства элемента.

    Пример использования модификатора .sync:
    <input type="text" v-bind:value.sync="likes"> или <input type="text" :value.sync="likes">

    Пример использования модификатора .sync с динамическим названием свойства:
    <input type="text" v-bind:[prop].sync="likes"> или <input type="text" :[prop].sync="likes">



     - Список модификаторов v-model: .lazy, .number, .trim

        Рассмотрим каждый из них подробнее:

        .lazy - изменение значения модели будет происходить только после потери фокуса (то есть, если у нас есть элемент input, и мы хотим, чтобы изменение
    значения модели происходило только после потери фокуса, то мы можем использовать модификатор .lazy).

    Пример использования модификатора .lazy:
    <input type="text" v-model.lazy="likes"> или <input type="text" v-model.lazy="likes">

        .number - привязывает значение к модели в числовом формате (то есть, если у нас есть элемент input, и мы хотим, чтобы значение модели было в
    числовом формате, то мы можем использовать модификатор .number).

    Пример использования модификатора .number:
    <input type="text" v-model.number="likes"> или <input type="text" v-model.number="likes">

        .trim - удаляет пробелы в начале и в конце строки (то есть, если у нас есть элемент input, и мы хотим, чтобы пробелы в начале и в конце строки
    удалялись, то мы можем использовать модификатор .trim).

    Пример использования модификатора .trim:
    <input type="text" v-model.trim="likes"> или <input type="text" v-model.trim="likes">

     - Список модификаторов v-slot: .prop, .camel, .sync

        Рассмотрим каждый из них подробнее:

        .prop - привязывает значение к свойству элемента (то есть, если у нас есть элемент input, и мы хотим привязать значение к свойству value, то мы
    можем использовать модификатор .prop).

    Пример использования модификатора .prop:
    <input type="text" v-slot:header.prop="likes"> или <input type="text" #header.prop="likes">

    Пример использования модификатора .prop с динамическим названием свойства:
    <input type="text" v-slot:[prop].prop="likes"> или <input type="text" #[prop].prop="likes">

        .camel - привязывает значение к свойству элемента в camelCase нотации (то есть, если у нас есть элемент input, и мы хотим привязать значение к
    свойству value в camelCase нотации, то мы можем использовать модификатор .camel).

    Пример использования модификатора .camel:
    <input type="text" v-slot:header.camel="likes"> или <input type="text" #header.camel="likes">

    Пример использования модификатора .camel с динамическим названием свойства:
    <input type="text" v-slot:[prop].camel="likes"> или <input type="text" #[prop].camel="likes">

        .sync - привязывает значение к свойству элемента и добавляет событие update (то есть, если у нас есть элемент input, и мы хотим привязать значение
    к свойству value и добавить событие update, то мы можем использовать модификатор .sync).

    Пример использования модификатора .sync:
    <input type="text" v-slot:header.sync="likes"> или <input type="text" #header.sync="likes">

    Пример использования модификатора .sync с динамическим названием свойства:
    <input type="text" v-slot:[prop].sync="likes"> или <input type="text" #[prop].sync="likes">

     - Список модификаторов v-on: .native, .capture, .once, .left, .right, .middle

        Рассмотрим каждый из них подробнее:

        .native - событие будет срабатывать на нативном элементе (то есть, если у нас есть вложенные элементы, и мы кликнули на внутренний элемент, то
    событие будет срабатывать только на внешнем элементе). Этот модификатор используется для того, чтобы событие срабатывало на нативном элементе,
    а не на компоненте. Это может быть полезно, если мы хотим использовать модификаторы событий на компоненте, который не имеет нативного аналога.

    Пример использования модификатора .native:
    <template>
    <div @click.native="clickHandler">
        <div @click="clickHandler"></div>
    </div>
    </template>

    <script>
    export default {
        methods: {
            clickHandler() {
                console.log('click')
            }
        }
    }
    </script>

        В этом случае событие будет срабатывать на нативном элементе. Если мы уберем модификатор .native, то событие будет срабатывать на компоненте.
    Это происходит потому, что по умолчанию событие срабатывает на компоненте. Если мы хотим, чтобы событие срабатывало на нативном элементе, то мы
    должны использовать модификатор .native.

        .capture - событие будет срабатывать на фазе захвата (то есть, если у нас есть вложенные элементы, и мы кликнули на внутренний элемент, то событие
    будет срабатывать сначала на внешнем элементе, а потом на внутреннем). Этот модификатор используется для того, чтобы событие срабатывало на фазе
    захвата.
        Фаза захвата - это первая фаза жизненного цикла события. В этой фазе событие сначала срабатывает на внешнем элементе, а потом на внутреннем.

    Пример использования модификатора .capture:
    <template>
    <div @click.capture="clickHandler">
        <div @click="clickHandler"></div>
    </div>
    </template>

    <script>
    export default {
        methods: {
            clickHandler() {
                console.log('click')
            }
        }
    }
    </script>

        В этом случае сначала сработает событие на внешнем элементе, а потом на внутреннем. Если мы уберем модификатор .capture, то сначала сработает событие
    на внутреннем элементе, а потом на внешнем. Это происходит потому, что по умолчанию событие срабатывает на фазе всплытия. Если мы хотим, чтобы
    событие срабатывало на фазе захвата, то мы должны использовать модификатор .capture.

        .once - событие будет срабатывать только один раз (то есть, если у нас есть вложенные элементы, и мы кликнули на внутренний элемент, то событие
    будет срабатывать только один раз).

    Пример использования модификатора .once:
    <template>
    <div @click.once="clickHandler">
        <div @click="clickHandler"></div>
    </div>
    </template>

    <script>
    export default {
        methods: {
            clickHandler() {
                console.log('click')
            }
        }
    }
    </script>

        В этом случае событие будет срабатывать только один раз. Если мы уберем модификатор .once, то событие будет срабатывать каждый раз, когда мы
    кликаем на элемент. Это происходит потому, что по умолчанию событие срабатывает каждый раз, когда мы кликаем на элемент. Если мы хотим, чтобы событие
    срабатывало только один раз, то мы должны использовать модификатор .once.

    Срабатывание события один раз необходимо для того, чтобы избежать проблем с производительностью. Если мы не используем модификатор .once, то событие
    будет срабатывать каждый раз, когда мы кликаем на элемент, и это может привести к проблемам с производительностью.

        .left - событие будет срабатывать только при клике левой кнопкой мыши (то есть, если у нас есть элемент, и мы хотим, чтобы событие срабатывало
    только при клике левой кнопкой мыши, то мы можем использовать модификатор .left).

    Пример использования модификатора .left:
    <template>
    <div @click.left="clickHandler">
        <div @click="clickHandler"></div>
    </div>
    </template>

    <script>
    export default {
        methods: {
            clickHandler() {
                console.log('click')
            }
        }
    }
    </script>

        В этом случае событие будет срабатывать только при клике левой кнопкой мыши. Если мы уберем модификатор .left, то событие будет срабатывать при
    клике любой кнопкой мыши. Это происходит потому, что по умолчанию событие срабатывает при клике любой кнопкой мыши. Если мы хотим, чтобы событие
    срабатывало только при клике левой кнопкой мыши, то мы должны использовать модификатор .left.

        .right - событие будет срабатывать только при клике правой кнопкой мыши (то есть, если у нас есть элемент, и мы хотим, чтобы событие срабатывало
    только при клике правой кнопкой мыши, то мы можем использовать модификатор .right).

    Пример использования модификатора .right:
    <template>
    <div @click.right="clickHandler">
        <div @click="clickHandler"></div>
    </div>
    </template>

    <script>
    export default {
        methods: {
            clickHandler() {
                console.log('click')
            }
        }
    }
    </script>

        В этом случае событие будет срабатывать только при клике правой кнопкой мыши. Если мы уберем модификатор .right, то событие будет срабатывать при
    клике любой кнопкой мыши. Это происходит потому, что по умолчанию событие срабатывает при клике любой кнопкой мыши. Если мы хотим, чтобы событие
    срабатывало только при клике правой кнопкой мыши, то мы должны использовать модификатор .right.

        .middle - событие будет срабатывать только при клике средней кнопкой мыши (то есть, если у нас есть элемент, и мы хотим, чтобы событие срабатывало
    только при клике средней кнопкой мыши, то мы можем использовать модификатор .middle).

    Пример использования модификатора .middle:
    <template>
    <div @click.middle="clickHandler">
        <div @click="clickHandler"></div>
    </div>
    </template>
    <script>
    export default {
        methods: {
            clickHandler() {
                console.log('click')
            }
        }
    }
    </script>

        В этом случае событие будет срабатывать только при клике средней кнопкой мыши. Если мы уберем модификатор .middle, то событие будет срабатывать при
    клике любой кнопкой мыши. Это происходит потому, что по умолчанию событие срабатывает при клике любой кнопкой мыши. Если мы хотим, чтобы событие
    срабатывало только при клике средней кнопкой мыши, то мы должны использовать модификатор .middle.

13 -- Динамические компоненты --:

        Динамические компоненты - это специальные компоненты, которые позволяют нам динамически менять компоненты в шаблоне. Для того, чтобы использовать
    динамические компоненты, мы должны использовать специальный элемент <component></component>. Внутри элемента <component></component> мы должны
    использовать атрибут is и в качестве значения атрибута is мы должны указать название компонента, который мы хотим отобразить. Если мы хотим
    отобразить компонент, то мы должны указать название компонента в качестве значения атрибута is. Если мы хотим скрыть компонент, то мы должны
    указать пустую строку в качестве значения атрибута is.

    Пример использования динамических компонентов:
    <template>
    <div>
        <button @click="showComponent = !showComponent">Показать/скрыть компонент</button>
        <component :is="showComponent ? 'ComponentA' : ''"></component>
    </div>
    </template>

    <script>
    import ComponentA from './ComponentA'
    export default {
        components: {
            ComponentA
        },
        data() {
            return {
                showComponent: true
            }
        }
    }
    </script>

        В этом случае мы отображаем компонент ComponentA, если значение переменной showComponent равно true, и мы скрываем компонент ComponentA, если
    значение переменной showComponent равно false. Если мы хотим отобразить компонент, то мы должны указать название компонента в качестве значения
    атрибута is. Если мы хотим скрыть компонент, то мы должны указать пустую строку в качестве значения атрибута is.

        Динамические компоненты позволяют нам динамически менять компоненты в шаблоне. Например, если мы хотим отобразить компонент ComponentA, то мы
    должны указать название компонента ComponentA в качестве значения атрибута is. Если мы хотим отобразить компонент ComponentB, то мы должны указать
    название компонента ComponentB в качестве значения атрибута is и так далее.

    Пример использования нескольких динамических компонентов:
    <template>
    <div>
        <button @click="showComponentA = !showComponentA">Показать/скрыть компонент A</button>
        <button @click="showComponentB = !showComponentB">Показать/скрыть компонент B</button>
        <button @click="showComponentC = !showComponentC">Показать/скрыть компонент C</button>
        <component :is="showComponentA ? 'ComponentA' : ''"></component>
        <component :is="showComponentB ? 'ComponentB' : ''"></component>
        <component :is="showComponentC ? 'ComponentC' : ''"></component>
    </div>
    </template>

    <script>
    import ComponentA from './ComponentA'
    import ComponentB from './ComponentB'
    import ComponentC from './ComponentC'
    export default {
        components: {
            ComponentA,
            ComponentB,
            ComponentC
        },
        data() {
            return {
                showComponentA: true,
                showComponentB: true,
                showComponentC: true
            }
        }
    }
    </script>

14 -- Динамические имена компонентов --:

        Динамические имена компонентов - это специальные компоненты, которые позволяют нам динамически менять компоненты в шаблоне. Для того, чтобы
    использовать динамические имена компонентов, мы должны использовать специальный элемент <component></component>. Внутри элемента <component></component>
    мы должны использовать атрибут is и в качестве значения атрибута is мы должны указать название переменной, которая содержит название компонента,
    который мы хотим отобразить. Если мы хотим отобразить компонент, то мы должны указать название переменной, которая содержит название компонента,
    который мы хотим отобразить, в качестве значения атрибута is. Если мы хотим скрыть компонент, то мы должны указать пустую строку в качестве
    значения атрибута is.

    Пример использования динамических имен компонентов:
    <template>
    <div>
        <button @click="componentName = 'ComponentA'">Показать компонент A</button>
        <button @click="componentName = 'ComponentB'">Показать компонент B</button>
        <button @click="componentName = 'ComponentC'">Показать компонент C</button>
        <component :is="componentName"></component>
    </div>
    </template>

    <script>
    import ComponentA from './ComponentA'
    import ComponentB from './ComponentB'
    import ComponentC from './ComponentC'
    export default {
        components: {
            ComponentA,
            ComponentB,
            ComponentC
        },
        data() {
            return {
                componentName: 'ComponentA'
            }
        }
    }
    </script>

        В этом случае мы отображаем компонент ComponentA, если значение переменной componentName равно 'ComponentA', и мы отображаем компонент ComponentB,
    если значение переменной componentName равно 'ComponentB', и мы отображаем компонент ComponentC,
    если значение переменной componentName равно 'ComponentC'.

        Динамические имена компонентов позволяют нам динамически менять компоненты в шаблоне. Например, если мы хотим отобразить компонент ComponentA, то
    мы должны указать название переменной, которая содержит название компонента ComponentA, в качестве значения атрибута is. Если мы хотим отобразить 
    компонент ComponentB, то мы должны указать название переменной, которая содержит название компонента ComponentB, в качестве значения атрибута is и
    так далее.

    Пример использования нескольких динамических имен компонентов:
    <template>
    <div>
        <button @click="componentNameA = 'ComponentA'">Показать компонент A</button>
        <button @click="componentNameB = 'ComponentB'">Показать компонент B</button>
        <button @click="componentNameC = 'ComponentC'">Показать компонент C</button>
        <component :is="componentNameA"></component>
        <component :is="componentNameB"></component>
        <component :is="componentNameC"></component>
    </div>
    </template>

    <script>
    import ComponentA from './ComponentA'
    import ComponentB from './ComponentB'
    import ComponentC from './ComponentC'
    export default {
        components: {
            ComponentA,
            ComponentB,
            ComponentC
        },
        data() {
            return {
                componentNameA: 'ComponentA',
                componentNameB: 'ComponentB',
                componentNameC: 'ComponentC'
            }
        }
    }
    </script>

15 -- Компонент keep-alive --:

        Компонент keep-alive - это специальный компонент, который позволяет нам сохранять состояние компонента. Для того, чтобы использовать компонент
    keep-alive, мы должны обернуть компонент в компонент keep-alive. Если мы хотим сохранить состояние компонента, то мы должны обернуть компонент в
    компонент keep-alive. Если мы хотим удалить состояние компонента, то мы должны удалить компонент из компонента keep-alive.
        Состояние компонента - это данные компонента. Если мы хотим сохранить данные компонента, то мы должны сохранить состояние компонента. Если мы
    хотим удалить данные компонента, то мы должны удалить состояние компонента.

    Пример использования компонента keep-alive:
    <template>
    <div>
        <button @click="showComponent = !showComponent">Показать/скрыть компонент</button>
        <keep-alive>
            <component v-if="showComponent" :is="componentName"></component>
        </keep-alive>
    </div>
    </template>

    <script>
    import ComponentA from './ComponentA'
    import ComponentB from './ComponentB'
    import ComponentC from './ComponentC'
    export default {
        components: {
            ComponentA,
            ComponentB,
            ComponentC
        },
        data() {
            return {
                showComponent: true,
                componentName: 'ComponentA'
            }
        }
    }
    </script>

        В этом случае мы сохраняем состояние компонента ComponentA, если значение переменной showComponent равно true, и мы удаляем состояние компонента
    ComponentA, если значение переменной showComponent равно false. Если мы хотим сохранить состояние компонента, то мы должны обернуть компонент в
    компонент keep-alive. Если мы хотим удалить состояние компонента, то мы должны удалить компонент из компонента keep-alive.

        Компонент keep-alive позволяет нам сохранять состояние компонента. Например, если мы хотим сохранить состояние компонента ComponentA, то мы
    должны обернуть компонент ComponentA в компонент keep-alive. Если мы хотим сохранить состояние компонента ComponentB, то мы должны обернуть компонент
    ComponentB в компонент keep-alive и так далее.

    Пример использования нескольких компонентов keep-alive:
    <template>
    <div>
        <button @click="showComponentA = !showComponentA">Показать/скрыть компонент A</button>
        <button @click="showComponentB = !showComponentB">Показать/скрыть компонент B</button>
        <button @click="showComponentC = !showComponentC">Показать/скрыть компонент C</button>
        <keep-alive>
            <component v-if="showComponentA" :is="componentNameA"></component>
        </keep-alive>
        <keep-alive>
            <component v-if="showComponentB" :is="componentNameB"></component>
        </keep-alive>
        <keep-alive>
            <component v-if="showComponentC" :is="componentNameC"></component>
        </keep-alive>
    </div>
    </template>

    <script>
    import ComponentA from './ComponentA'
    import ComponentB from './ComponentB'
    import ComponentC from './ComponentC'
    export default {
        components: {
            ComponentA,
            ComponentB,
            ComponentC
        },
        data() {
            return {
                showComponentA: true,
                showComponentB: true,
                showComponentC: true,
                componentNameA: 'ComponentA',
                componentNameB: 'ComponentB',
                componentNameC: 'ComponentC'
            }
        }
    }
    </script>

16 -- Динамические имена компонентов и компонент keep-alive --:

        Динамические имена компонентов и компонент keep-alive - это специальные компоненты, которые позволяют нам динамически менять компоненты в шаблоне
    и сохранять состояние компонента. Для того, чтобы использовать динамические имена компонентов и компонент keep-alive, мы должны использовать
    специальный элемент <component></component>. Внутри элемента <component></component> мы должны использовать атрибут is и в качестве значения атрибута
    is мы должны указать название переменной, которая содержит название компонента, который мы хотим отобразить. Если мы хотим отобразить компонент,
    то мы должны указать название переменной, которая содержит название компонента, который мы хотим отобразить, в качестве значения атрибута is. Если
    мы хотим скрыть компонент, то мы должны указать пустую строку в качестве значения атрибута is. Если мы хотим сохранить состояние компонента, то
    мы должны обернуть компонент в компонент keep-alive. Если мы хотим удалить состояние компонента, то мы должны удалить компонент из компонента
    keep-alive.

    Пример использования динамических имен компонентов и компонента keep-alive:
    <template>
    <div>
        <button @click="componentName = 'ComponentA'">Показать компонент A</button>
        <button @click="componentName = 'ComponentB'">Показать компонент B</button>
        <button @click="componentName = 'ComponentC'">Показать компонент C</button>
        <keep-alive>
            <component :is="componentName"></component>
        </keep-alive>
    </div>
    </template>

    <script>
    import ComponentA from './ComponentA'
    import ComponentB from './ComponentB'
    import ComponentC from './ComponentC'
    export default {
        components: {
            ComponentA,
            ComponentB,
            ComponentC
        },
        data() {
            return {
                componentName: 'ComponentA'
            }
        }
    }
    </script>

        В этом случае мы сохраняем состояние компонента ComponentA, если значение переменной componentName равно 'ComponentA', и мы сохраняем состояние
    компонента ComponentB, если значение переменной componentName равно 'ComponentB', и мы сохраняем состояние компонента ComponentC, если значение
    переменной componentName равно 'ComponentC'. Если мы хотим сохранить состояние компонента, то мы должны обернуть компонент в компонент keep-alive.
    Если мы хотим удалить состояние компонента, то мы должны удалить компонент из компонента keep-alive.

        Динамические имена компонентов и компонент keep-alive позволяют нам динамически менять компоненты в шаблоне и сохранять состояние компонента.
    Например, если мы хотим отобразить компонент ComponentA, то мы должны указать название переменной, которая содержит название компонента ComponentA,
    в качестве значения атрибута is. Если мы хотим отобразить компонент ComponentB, то мы должны указать название переменной, которая содержит название
    компонента ComponentB, в качестве значения атрибута is и так далее. Если мы хотим сохранить состояние компонента ComponentA, то мы должны обернуть
    компонент ComponentA в компонент keep-alive. Если мы хотим сохранить состояние компонента ComponentB, то мы должны обернуть компонент ComponentB в
    компонент keep-alive и так далее.

    Пример использования нескольких динамических имен компонентов и компонента keep-alive:
    <template>
    <div>
        <button @click="componentNameA = 'ComponentA'">Показать компонент A</button>
        <button @click="componentNameB = 'ComponentB'">Показать компонент B</button>
        <button @click="componentNameC = 'ComponentC'">Показать компонент C</button>
        <keep-alive>
            <component :is="componentNameA"></component>
        </keep-alive>
        <keep-alive>
            <component :is="componentNameB"></component>
        </keep-alive>
        <keep-alive>
            <component :is="componentNameC"></component>
        </keep-alive>
    </div>
    </template>

    <script>
    import ComponentA from './ComponentA'
    import ComponentB from './ComponentB'
    import ComponentC from './ComponentC'
    export default {
        components: {
            ComponentA,
            ComponentB,
            ComponentC
        },
        data() {
            return {
                componentNameA: 'ComponentA',
                componentNameB: 'ComponentB',
                componentNameC: 'ComponentC'
            }
        }
    }
    </script>

17 -- Слоты --:

        Слоты - это специальные элементы, которые позволяют нам передавать контент в компонент. Для того, чтобы использовать слоты, мы должны использовать
    специальный элемент <slot></slot>. Внутри элемента <slot></slot> мы должны использовать контент, который мы хотим передать в компонент. Если мы хотим
    передать контент в компонент, то мы должны использовать слоты. Если мы не хотим передавать контент в компонент, то мы не должны использовать слоты.

18 -- Жизненный цикл компонента --:

    Хуки жизненного цикла: beforeCreate, created, beforeMount, mounted, beforeUpdate, updated, beforeDestroy, destroyed

        Хуки жизненного цикла - это специальные методы, которые позволяют нам выполнять код в определенный момент жизненного цикла компонента. Всего
    существует восемь хуков жизненного цикла: beforeCreate, created, beforeMount, mounted, beforeUpdate, updated, beforeDestroy, destroyed. Каждый из
    этих хуков жизненного цикла выполняется в определенный момент жизненного цикла компонента.

            ( Все хуки жизненного цикла автоматически привязывают свой контекст this к экземпляру, поэтому есть доступ к локальному состоянию,
            вычисляемым свойствам и методам. Нельзя использовать стрелочные функции при определении хука жизненного цикла
            (например, created: () => this.fetchTodos()). Причина в том, что стрелочные функции привязываются к родительскому контексту,
            поэтому this не будет экземпляром компонента и this.fetchTodos будет неопределён. )

    Например:

    - хук beforeCreate выполняется до того, как компонент будет создан. На этом этапе инициализиуются свойства компонента (события и жизненный цикл),
    но реактивность еще не работает. Сам хук  beforeCreate используется редко, так как в этот момент еще нет доступа к данным компонента,
    Вызывается синхронно сразу после инициализации экземпляра, перед установкой наблюдения за данными и механизмов слежения и событий.

    - хук created выполняется после того, как компонент будет создан. На этом этапе в компонент добавляются различные инъекции (например, $el,
    $data, $props, $options, $parent, $root, $children, $slots, $refs, $isServer, $attrs, $listeners и т.д.), но реактивность еще не работает.
    Сам хук created используется чаще всего, так как в этот момент уже есть доступ к данным компонента, но еще не произошла отрисовка компонента.
    В этом хуке мы можем выполнять запросы, дефолтную инициализацию, проверять условия и т.д., после чего отрабатывает рендер функция и
    появляются два новых хука: beforeMount и mounted.

    Вызывается синхронно после создания экземпляра. На этом этапе экземпляр закончил обработку опций и настроил: наблюдение за данными,
    вычисляемые свойства, методы, коллбэки методов-наблюдателей и событий. Однако, фаза монтирования ещё не начата и свойство $el на данный момент
    недоступно.

    - хук beforeMount выполняется до того, как компонент будет отображен (смонтирован в ДОМ-дерево). Вызывается непосредственно перед началом монтирования:
    функция render будет вызываться в первый раз.

    - хук mounted выполняется после того, как компонент будет отображен (после того, как компонент будет смонтирован в ДОМ-дерево). Этот хук является
    самым часто используемым, так как в этот момент уже есть доступ к данным компонента и компонент уже отрисован. В этом хуке мы можем выполнять
    запросы на сервер, работать с DOM-элементами, добавлять слушателей событий и т.д., после чего компонент отображается на странице. После того, как
    компонент будет отображен, мы можем изменять данные компонента, и это приведет к тому, что компонент будет обновлен. После того, как компонент будет
    обновлен, снова отрабатывает рендер функция и появляются два новых хука: beforeUpdate и updated,

    - хук beforeUpdate выполняется до того, как компонент будет обновлен. Вызывается непосредственно перед изменением данных, которые отображаются в шаблоне,
    и повторным рендерингом. В этом хуке мы можем получить доступ к данным компонента до того, как компонент будет обновлен, и это позволяет нам
    сравнить старые данные компонента с новыми данными компонента. Если мы хотим получить доступ к данным компонента до того, как компонент будет
    обновлен, то мы должны использовать хук beforeUpdate. Если мы хотим получить доступ к данным компонента после того, как компонент будет обновлен,
    то мы должны использовать хук updated.

    - хук updated выполняется после того, как компонент будет обновлен. Вызывается после изменения данных, которые отображаются в шаблоне, и повторного
    рендеринга. В этом хуке мы можем получить доступ к данным компонента после того, как компонент будет обновлен, и это позволяет нам сравнить старые
    данные компонента с новыми данными компонента.

    В последующих хуках мы чаще всего делаем какую-то очистку (например, отписываемся от событий, удаляем слушателей событий, очищаем стор,
    удаляем таймеры и т.д.),

    - хук beforeDestroy выполняется до того, как компонент будет удален. Вызывается непосредственно перед уничтожением экземпляра. В этом хуке мы можем
    получить доступ к данным компонента до того, как компонент будет удален, и это позволяет нам сохранить данные компонента. Если мы хотим получить
    доступ к данным компонента до того, как компонент будет удален, то мы должны использовать хук beforeDestroy. Если мы хотим получить доступ к данным
    компонента после того, как компонент будет удален, то мы должны использовать хук destroyed.

    - хук destroyed выполняется после того, как компонент будет удален. Вызывается после того, как экземпляр компонента будет уничтожен. В этом хуке мы
    можем получить доступ к данным компонента после того, как компонент будет удален, и это позволяет нам сохранить данные компонента.

        Хуки жизненного цикла позволяют нам выполнять код в определенный момент жизненного цикла компонента. Например, если мы хотим выполнить код до
    того, как компонент будет создан, то мы должны использовать хук beforeCreate. Если мы хотим выполнить код после того, как компонент будет создан,
    то мы должны использовать хук created и так далее.

    Пример использования хуков жизненного цикла:
    <template>
    <div>
        <p>{{ message }}</p>
        <button @click="changeMessage">Изменить сообщение</button>
    </div>
    </template>

    <script>
    export default {
        data() {
            return {
                message: 'Hello World!'
            }
        },
        beforeCreate() {
            console.log('beforeCreate')
        },
        created() {
            console.log('created')
        },
        beforeMount() {
            console.log('beforeMount')
        },
        mounted() {
            console.log('mounted')
        },
        beforeUpdate() {
            console.log('beforeUpdate')
        },
        updated() {
            console.log('updated')
        },
        beforeDestroy() {
            console.log('beforeDestroy')
        },
        destroyed() {
            console.log('destroyed')
        },
        methods: {
            changeMessage() {
                this.message = 'Hello Vue!'
            }
        }
    }
    </script>

    Диаграмма жизненного цикла: https://ru.vuejs.org/images/lifecycle.png

    Если говорить коротко, компонет проходит четыре стадии: создание, монтирование, обновление и удаление.

19 -- Наблюдаемые свойства vue --:

    Наблюдаемые свойства - это функция, которая отрабатывает в тот момент, когда какая-то из моделей компонента была изменена.
    Для того, чтобы использовать наблюдаемые свойства, мы должны использовать функцию watch. Внутри функции watch мы должны использовать
    название свойства, за которым мы хотим следить, и в качестве значения функции watch мы должны использовать функцию,
    которая будет вызываться при изменении свойства, за которым мы хотим следить.

    Пример использования наблюдаемых свойств:
    <template>
    <div>
        <p>{{ message }}</p>
        <button @click="changeMessage">Изменить сообщение</button>
    </div>
    </template>

    <script>
    export default {
        data() {
            return {
                message: 'Hello World!'
            }
        },
        watch: {
            message() {
                console.log('message changed')
            }
        },
        methods: {
            changeMessage() {
                this.message = 'Hello Vue!'
            }
        }
    }
    </script>

        В этом случае функция watch будет вызываться при изменении свойства message.

20 -- Вычисляемые свойства vue --:

    Вычисляемые свойства - єто фнукция, которая обязательно должна возвращать какое-то значение. Для того, чтобы использовать вычисляемые свойства,
    мы должны использовать функцию computed. Внутри функции computed мы должны использовать название свойства, которое мы хотим вычислить,
    и в качестве значения функции computed мы должны использовать функцию, которая будет возвращать значение свойства, которое мы хотим вычислить.

    Как пример, она может возвращать отсортированній массив, который будет отсортирован по какому-то критерию, или она может возвращать результат
    какой-то математической операции, или она может возвращать результат какой-то логической операции и т.д.

    Функция computed отличается от обычной функции тем, что при вызове обычной функции в модели компонента, она будет отрабатывать каждый раз, когда
    будет рендериться компонент, а функция computed будет вызвана лишь единожды, и в последующие случаи она будет возвращать лишь запомненный результат,
    своего рода кеширование. И заново эта фнукция будет делать перерасчет только в том случае, если какое-то из свойств или зависимостей,
    которые используются внутри этой функции, будет изменено.

    Пример использования вычисляемых свойств:
    <template>
    <div>
        <p>{{ message }}</p>
        <button @click="changeMessage">Изменить сообщение</button>
    </div>
    </template>

    <script>
    export default {
        data() {
            return {
                message: 'Hello World!'
            }
        },
        computed: {
            messageLength() {
                return this.message.length
            }
        },
        methods: {
            changeMessage() {
                this.message = 'Hello Vue!'
            }
        }
    }
    </script>

        В этом случае функция computed будет вызываться при изменении свойства message, запишет его значение в кеш и будет вызвана снова только при
        изменении свойства message.

21 -- Миксины --:

        Миксины - это специальные объекты, которые позволяют нам использовать один и тот же код в разных компонентах. Для того, чтобы использовать
    миксины, мы должны использовать свойство mixins в компоненте, куда мы хотим их добавить. В качестве значения свойства mixins мы должны
    использовать массив, в котором мы должны указать название миксинов, которые мы хотим использовать (Миксинов, передающихся в объект может быть
    несколько.).

        Сначала объявляем объект миксина с нужными свойствами и методами в файле myMixin.js, а затем подключаем его в компоненте, в котором хотим
    использовать миксин, в свойстве mixins, в таком виде: mixins: [myMixin].

    Объявление миксина в файле myMixin.js:

        export default {
        props: {
            show: {
                type: Boolean,
                default: false,
            },
        },
        emits: ['update:show'],
        methods: {
            hideDialog() {
                this.$emit('update:show', false)
            },
        },
        mounted() {
            console.log('mixin mounted')
        },
    }

    Подключение миксина в компоненте:

    <script>
    import myMixin from '@/mixins/myMixin'
    export default {
        name: 'my-component',
        mixins: [myMixin],
    }
    </script>

        Если после подключения миксина у нас есть какой-то метод жизненного цикла с таким же названием внутри компонента,
        то сначала отработает метод миксина, а затем метод компонента.

    <script>
    import myMixin from '@/mixins/myMixin'
    export default {
        name: 'my-component',
        mixins: [myMixin],
        mounted() {
        console.log('more mounted')
    },
    }
    </script>

    В этом случае в консоль сначала выведется значение 'mixin mounted', а затем значение 'more mounted'.

    В случаях, когда миксин и компонент содержат одинаковые опции, они будут объединяться определённым образом.

    Например, каждая миксин может иметь свою собственную функцию data. Каждая из них будет вызвана, а возвращённые объекты объединены.
    Свойства из data компонента при этом будут иметь приоритет в случае конфликта.

    const myMixin = {
    data() {
        return {
        message: 'hello',
        foo: 'abc'
        }
    }
    }

    const app = Vue.createApp({
    mixins: [myMixin],
    data() {
        return {
        message: 'goodbye',
        bar: 'def'
        }
    },
    created() {
        console.log(this.$data) // => { message: "goodbye", foo: "abc", bar: "def" }
    }
    })

    В данном случае свойсвто миксина message будет перезаписано свойством компонента message, а свойство компонента bar будет добавлено к свойствам
    миксина.

    Опции, значения которых будут объектами, такие как methods, components и directives будут объединены.
    В случае конфликтов приоритет будет у опций компонента:

    const myMixin = {
    methods: {
        foo() {
        console.log('foo')
        },
        conflicting() {
        console.log('из примеси')
        }
    }
    }

    const app = Vue.createApp({
    mixins: [myMixin],
    methods: {
        bar() {
        console.log('bar')
        },
        conflicting() {
        console.log('из самого компонента')
        }
    }
    })

    const vm = app.mount('#mixins-basic')

    vm.foo() // => "foo"
    vm.bar() // => "bar"
    vm.conflicting() // => "из самого компонента"

    В данном примере методы foo и bar будут объединены, а метод conflicting будет перезаписан методом компонента.

22 -- Управление состоянием приложения (Глобальное хранилище Vuex) --:

        Для начала познакомимся с понятием "глобального хранилища". Глобальное хранилище - это объект, который содержит в себе данные, которые могут
        бытьиспользованы в любом компоненте приложения.

        Во Vue роль глобального хранилища исполняет "Vuex".

        Vuex - это библиотека, которая позволяет нам управлять состоянием приложения.

        Vuex хранит в себе переменные, свойства и функции, которые могут быть переданы в любой компонент приложения по запросу к хранилищу из одного
    из компонентов для упрощения работы с данными, и исключения передачи их по длинной цепочке из корневого компонента в дочерний.

        Так же благодаря Vuex очень удобно делать некую декомпозицию данных и логики, вынесенных из компонента, оставляя компоненту только задачу
    отображения, а сами данные и логика по работе с этими данными вынесены во Vuex.

        Для того, чтобы использовать Vuex, мы должны установить его в приложение.

        Для того, чтобы установить Vuex в приложение, мы должны выполнить команду "npm install vuex@next --save" либо "yarn add vuex@next --save"
    в терминале.

        После того, как мы установили Vuex в приложение, мы можем использовать его в приложении.

        Vuex состоит из четырех частей: state, getters, mutations и actions.

            - State - это само состояние, в котором описываются данные, используемые в нашем приложении. Это объект, который содержит в себе данные,
        которые могут быть использованы в любом компоненте приложения.

            - Getters - это функция (computed свойства, кешируемые, вычисляемые значения), которая позволяет нам получить доступ к свойствам state.

            - Mutations - это функция, внутри которой мы меняем значение какого-то поля в состоянии, позволяет нам изменять свойства state (позволяет
        изменять состояния, поскольку изменять состояния напрямую нельзя).

            - Actions - это функция, которая внутри себя использует mutations, поскольку напрямую из Actions менять состояние не рекомендуется.

        Внутри Actions мы делаем какие-то сайт-эффекты, например, отправляем запрос на сервер, получаем данные с сервера, и после того, как мы
        получили данные, вызываем мутацию этих данных и сохраняем результат в состояние.

        Чтобы "Глобальное хранилище" не превратилось в мусорку в большом приложении, были придуманы модули.

        Один модуль представляет из себя изолированный кусок состояния со своими геттерами, мутациями и екшенами.
        И все эти модули подключаются в один глобальный стор (хранилище).

23 Composition API

	Composition API во Vue.js - это новый способ организации компонентов и логики во Vue 3, представленный как альтернатива классическому определению компонентов с использованием объекта `data`, `methods`, `computed`, и так далее. Composition API предоставляет более гибкий и модульный подход к созданию компонентов, позволяя разделять логику на более мелкие и переиспользуемые части.

Основные принципы Composition API включают:

1. **Составление (Composition)**: Вы можете создавать композиции из нескольких функций, которые содержат состояние, методы и вычисляемые свойства. Эти функции могут быть использованы в разных компонентах для легкой переиспользуемости.

2. **Подъем важных концепций**: Composition API позволяет изолировать и поднимать концепции, такие как реактивное состояние (с использованием `ref` и `reactive`), методы (с использованием `methods`), и вычисляемые свойства (с использованием `computed`).

3. **Минимизация мутации состояния**: В Composition API вы манипулируете реактивными объектами (созданными с использованием `ref` или `reactive`) без прямой мутации, что делает код более предсказуемым и легко отслеживаемым.

4. **Улучшенная типизация**: Composition API обеспечивает лучшую поддержку для типизации с помощью TypeScript.

Пример использования Composition API:

```vue
<template>
  <div>
    <p>Count: {{ count }}</p>
    <button @click="increment">Increment</button>
  </div>
</template>

<script>
import { ref } from 'vue';

export default {
  setup() {
    const count = ref(0);

    const increment = () => {
      count.value++;
    };

    return { count, increment };
  }
}
</script>
```

Здесь `setup` - это функция, возвращающая объект, который экспортируется в шаблон. Внутри этой функции вы определяете состояние `count` и метод `increment`, и затем возвращаете их для использования в шаблоне. Это позволяет создавать композиции и переиспользовать логику в разных компонентах.

Composition API предоставляет более мощный и удобный способ создания компонентов в Vue.js 3, особенно для более сложных приложений.

=====================================================================================

Необязательные поля в Typescript можно указать с помощью знака вопроса (?).

interface User { FirstName: string, LastName?: string }




















