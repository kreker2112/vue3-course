VUE (Фреймворк):

Концепции:

1 -- VirtualDom --:
        Самая важная концепция это Virtual Dom. После парсинга HTML Страницы браузер строит DOM-дерево и каждая операция
    с DOM-деревом это крайне ресурсоемкая сложная задача. И чтобы оптимизировать процессы ререндеринга страницы, Vue под капотом строит, так
    называемое, Виртуальное DOM-дерево. И если говорить совсем кратко, Vue накапливает количество изменений, которые необходимо отобразить на странице,
    после чего сравнивает оригинальную версию DOM-дерева страницы и нашу виртуальную копию, и сразу всей пачкой все изменения применяются к DOM-дереву,
    после чего мы видим обновленную страницу с новыми данными

2 -- Компонентный подход --:
        Vue пропагандирует компонентный подход:
    Все приложение делится на маленькие, большие и переиспользуемые куски (компоненты). Разрабатывая каждый компонент важно помнить, что зачастую они
    являются переиспользуемыми, то есть, у нас в приложении есть пять страниц и в каждую из них мы можем вставить компонент со списком пользователей,
    и все от чего он зависит, это от входных параметров, то есть в этот компонент мы передали какой-то массив с объектами, где каждый объект представляет
    из себя описание пользователя, и все, мы должны быть уверенными, что этот компонент отрисует нам список.

            При компонентном подходе у Дом-дерева всегда один узел, это самый корневой родительский компонент, который чаще всего называется App.vue.
        В этот компонент помещаются другие компоненты (к примеру: большие компоненты: Навигационное меню Menu.vue и список пользователей UserList.vue,
        в свою очередь Навигационное меню Menu.vue и список пользователей UserList.vue содержат внутри себя меньшие компоненты: В Навигационном меню
        это шапка меню MenuHeader.vue и отдельный элемент меню MenuItem.vue, а список пользователей UserList.vue состоит из какого-то количества
        пользователей UserItem.vue)

3 -- Реактивность --:
        К примеру, для работы без фреймворка, со счетчиком по клику на кнопке, для взаимодействия HTML элемента и интерактива с кликом, чтобы были видны
    изменения данных на странице по клику, необходимо ссылку на блок с аутпутом, в котором отображена переменная счетчика, поместить внуть слушателя событий.
    То есть, данные, с которыми мы работаем и графическое представление никак не связаны, и приходится руками брать счетчик и подставлять в необходмый
    для нас блок.

        При реализации такого же функционала при помощи Vue, мы объявляем внутри компонента переменную:

        data() {
            return {
                likes: 0
            }
        }

        , в которую будет записываться результат счетчика
    (Во Vue подобные значения называются моделями) и внутри этого же компонента есть шаблон разметки:

    <div>Кол-во лайков = {{ likes }}</div>
    <button @click="likes += 1">Поставить лайк</button>

    в который встраиваем модель переменной, вешаем слушатель
    события на кнопку и просто инкрементируем каждое значение счетчика по нажатию на кнопку.

    То есть при реактивности у программиста упор идет больше на работу с данными, нежели с тем, как синхрониховать эти данные с нашей страницей

        Как работает реактивность:
    Внутри компонента мы объявили некоторую модель, которая по дефолту равняется 0 (кол-во лайков).
    Далее невидимым для нас образом Vue под капотом оборачивает каждую модель в обычный JavaScript-овый Proxy, который позволяет установить некоторые ловушки
    на объект, например, одна из ловушек может отрабатывать, когда объект был изменен, так вот Vue оборачивает модель в Proxy и добавляет ловушки на геттеры
    и сеттеры, то етсь на изменение и получение объекта, и вот как раз в тот момент, когда мы пытаемся изменить ту, или иную модель, срабатывает ловушка set(),
    которая срабатывает в тот момент, когда мы изменили значение и Vue вызывает render функцию для обновления интерфейса на экране с новыми данными

                                                Реактивность

                                               ________ model
                                              |
                                              |
            data() {                          |
                return {                      |
                    likes: 0 _________________|____
                    }                              |
                }                                  |
                                                   |
                                                    new Proxy (likes, {
                                                      get() {}
                                                      Set() {
                                                         render();
                                                      }cd
                                                    })

    Это удобно, поскольку мы сосредотачиваемся на логике работы с данными (мы каким-то образом, невожно каким, изменили значение счетчика, и мы можем
    быть уверенны, что интерфейс у нас обновится)

4 -- Создание проекта --:
    Сначала установить yarn global add @vue/cli
    Создать проект: vue create vue3-course
    Настроить Проект: vue create .
    Запустить проект: yarn serve
     -- Все настройки проекта хранятся в файле vue.config.js (который создается автоматически при создании проекта)
     -- В нем можно настроить пути к папкам, в которых хранятся компоненты, стили, картинки и т.д. (по умолчанию все
        компоненты хранятся в папке src/components)

     -- Все компоненты в проекте должны иметь расширение .vue (которое означает, что это Vue-компонент)

     -- Все компоненты в проекте должны иметь три секции:
        1 -- template --: в которой хранится разметка компонента
        2 -- script --: в которой хранится логика компонента
        3 -- style --: в которой хранится стили компонента

    -- Все компоненты в проекте должны иметь один корневой элемент (который оборачивает весь компонент)

    -- Все компоненты в проекте должны иметь уникальное имя (которое должно начинаться с большой буквы)

5 -- Двустороннее связывание--:

    Задача дустороннего связывания это связать модель и шаблон, то есть, когда мы меняем данные в модели, они автоматически меняются в шаблоне,

    Двустороннее связывание это когда мы можем изменять данные в модели и они автоматически будут меняться в шаблоне,
    и наоборот, когда мы изменяем данные в шаблоне, они автоматически меняются в модели.

    К примеру, у нас есть модель, которая хранит в себе некоторое значение, и в шаблоне мы хотим отобразить это значение,
    и при этом мы хотим, чтобы при изменении значения в шаблоне, оно автоматически менялось в модели, и наоборот,
    когда мы меняем значение в модели, оно автоматически менялось в шаблоне.

    Для этого в Vue есть директива v-model, которая позволяет нам связать модель и шаблон.

    Для того, чтобы связать модель и шаблон, необходимо в шаблоне в элементе, в котором мы хотим отобразить значение модели,
    добавить директиву v-model и в качестве аргумента передать название модели, которую мы хотим связать с этим элементом.

    К примеру, у нас есть модель, которая хранит в себе значение likes, и в шаблоне мы хотим отобразить это значение,
    и при этом мы хотим, чтобы при изменении значения в шаблоне, оно автоматически менялось в модели, и наоборот,
    когда мы меняем значение в модели, оно автоматически менялось в шаблоне.

    Для этого в шаблоне в элементе, в котором мы хотим отобразить значение модели, добавляем директиву v-model и в качестве аргумента
    передаем название модели, которую мы хотим связать с этим элементом.

    <div>Кол-во лайков = {{ likes }}</div>
    <button @click="likes += 1">Поставить лайк</button>
    <input type="text" v-model="likes">

             Двустороннее связывание (таблица событий и атрибутов)
    ___________________________________________________________
   |                |                    |                     |
   |    Элемент     |      Событие       |        Атрибут      |
   |________________|____________________|_____________________|
   |  - input       |                    |                     |
   |  - textarea    |      oninput       |        VALUE        |
   |________________|____________________|_____________________|
   |  -checkbox     |                    |                     |
   |  -radio btn    |      onchange      |        CHECKED      |
   |________________|____________________|_____________________|
   |                |                    |                     |
   |  -списки       |      onchange      |         VALUE       |
   |________________|____________________|_____________________|

   Инпут, чекбоксы и списки встечаются часто, поэтому для них есть сокращенная запись:
   (v-model="likes" вместо v-bind:value="likes" и v-on:input="likes = $event.target.value" вместо @input="likes = $event.target.value")

6 -- Директивы --:
    Директивы это специальные атрибуты, которые позволяют нам добавлять некоторую логику в шаблон.

    Директивы в Vue начинаются с префикса v- (v-model, v-if, v-show, v-for, v-on, v-bind, v-text, v-html, v-pre, v-cloak, v-once, v-slot, v-is)

     -- Директива v-model позволяет нам связать модель и шаблон (обеспечить двустороннее связывание).

            Пример использования директивы v-model:
            <input type="text" v-model="likes">

     -- Директива v-show добавляет в шаблон элемент, если условие истинно, и удаляет элемент из шаблона, если условие ложно.

            Пример использования директивы v-show:
            <div v-show="likes > 0">Кол-во лайков = {{ likes }}</div>

     -- Директива v-if позволяет нам добавлять условную логику в шаблон (в зависимости от условия элемент будет отображаться или нет) (в отличии от v-show,
    который просто скрывает элемент, но он все равно есть в DOM-дереве, v-if удаляет элемент из DOM-дерева, если условие ложно).

            Для того, чтобы добавить условную логику в шаблон, необходимо в элементе, в котором мы хотим добавить условную логику,
            добавить директиву v-if и в качестве аргумента передать название модели, которая будет хранить в себе условие,
            по которому будет происходить отображение элемента.

            Пример использования директивы v-if:
            <div v-if="likes > 0">Кол-во лайков = {{ likes }}</div>
            <button @click="likes += 1">Поставить лайк</button>

     -- Директива v-for позволяет нам добавлять циклы в шаблон (в зависимости от кол-ва элементов в массиве, в шаблоне будет отображаться соответствующее
    кол-во элементов).

            Пример использования директивы v-for:
            <div v-for="post in posts" :key="post.id">
                <h1>{{ post.title }}</h1>
                <p>{{ post.text }}</p>

     -- Директива v-on позволяет нам добавлять обработчики событий в шаблон (в зависимости от события, будет выполняться определенная логика).
            Чаще всего используется его сокращенный вариант @ (к примеру, @click="likes += 1").

            Пример использования директивы v-on:
            <button @click="likes += 1">Поставить лайк</button>

     -- Директива v-bind позволяет нам добавлять атрибуты в шаблон.
            Сокращенная запись v-bind: : (к примеру, :src="image").

            Пример использования директивы v-bind:
            <img v-bind:src="image" alt="">

     -- Директива v-text позволяет нам добавлять текстовый контент в шаблон (вместо двойных фигурных скобок {{}}).

            Пример использования директивы v-text:
            <div v-text="likes"></div>

     -- Директива v-html позволяет нам добавлять HTML контент в шаблон (вместо двойных фигурных скобок {{}}).

            Пример использования директивы v-html:
            <div v-html="likes"></div>

     -- Директива v-pre позволяет нам отключить компиляцию шаблона
            (все директивы и интерполяции внутри элемента с директивой v-pre будут отображаться как есть).

            Пример использования директивы v-pre:
            <div v-pre>{{ likes }}</div>

     -- Директива v-cloak позволяет нам скрыть незакомпилированный шаблон (все элементы с директивой v-cloak будут скрыты до момента компиляции шаблона).

            Пример использования директивы v-cloak:
            <div v-cloak>{{ likes }}</div>

     -- Директива v-once позволяет нам отрисовать шаблон только один раз (при изменении данных в шаблоне, шаблон не будет перерисовываться).

            Пример использования директивы v-once:
            <div v-once>{{ likes }}</div>

     -- Директива v-slot позволяет нам передавать контент в слоты (для того, чтобы передать контент в слот, необходимо в элементе, в котором мы хотим
    передать контент в слот, добавить директиву v-slot и в качестве аргумента передать название слота).

            Пример использования директивы v-slot:
            <template v-slot:header>
                <h1>Заголовок</h1>
            </template>

     -- Директива v-is позволяет нам динамически выбирать компоненты (для того, чтобы использовать директиву v-is, необходимо в элементе, в котором мы хотим
    использовать директиву v-is, добавить директиву v-is и в качестве аргумента передать название компонента, который мы хотим использовать).

            Пример использования директивы v-is:
            <div v-is="component"></div>



     -- Директива v-show позволяет нам добавлять условную логику в шаблон.

            Для того, чтобы добавить условную логику в шаблон, необходимо в элементе, в котором мы хотим добавить условную логику,
            добавить директиву v-show и в качестве аргумента передать название модели, которая будет хранить в себе условие,
            по которому будет происходить отображение элемента.

            <div v-show="likes > 0">Кол-во лайков = {{ likes }}</div>

7 -- Пропсы --:
    Пропсы это входные параметры, которые передаются в дочерний компонент из родительского.
    Пропсы нельзя изменять в дочернем компоненте, они только для чтения, а изменяться
    они должны в родительском компоненте, а дочерний компонент должен получать их уже в измененном виде. Сам он их изменять не может.

    Для того, чтобы передать пропсы в дочерний компонент, необходимо в теге дочернего компонента добавить атрибут
    v-bind:имя_пропса="значение_пропса". Имя пропса должно быть в camelCase нотации. В качестве значения пропса
    может быть какая-то переменная, так и просто строка. В дочернем компоненте пропсы доступны в объекте props.

    <template>
        <div>
            <h1>{{ title }}</h1>
            <p>{{ text }}</p>
        </div>
    </template>

    <script>
        export default {
            name: 'Post',
            props: {
                title: {
                    type: String,
                    required: true
                },
                text: {
                    type: String,
                    required: true
                }
            }
        }
    </script>

    <style scoped>
        h1 {
            color: red;
        }
    </style>

    В примере выше мы передаем в дочерний компонент Post два пропса: title и text. В шаблоне дочернего компонента мы
    выводим эти пропсы в разметку. В скрипте дочернего компонента мы объявляем объект props, в котором мы указываем
    название пропса и его тип. Также мы можем указать, является ли пропс обязательным или нет. Если пропс обязательный,
    то в случае, если он не будет передан в дочерний компонент, то в консоли будет выведена ошибка. Если пропс не
    обязательный, то в случае, если он не будет передан в дочерний компонент, то в консоли ошибки не будет.

8 -- Взаимодействие дочернего компонента и родительского --:



                                __________________________
                               |                          |_______________  @create="createPost"
                               |         Родитель         |               | подписывается на событие так же, как и на input, click и т.д.
                               |__________________________|               | Эти нативные события аргументом принимают объект события (ивент)
                               |                                          | И если мы подпишемся на событие @create, аргументом мы будем
                        Список | Props                                    | принимать событие CREATE(POST), которое мы сгенерировали в дочернем
                        постов |                                          | компоненте.
                               |                                          | Для подписки на событие в родительском компоненте используется
                             _\|/____________________________             | функция $emit, которая принимает два параметра: название события и
                            |                                |            | данные, которые мы хотим передать в родительский компонент
                            |                                |           \|/
                            |                                |    генерируем событие
                            |            Ребенок             |       CREATE(POST) (это идентично событию click, change и т.д.)
                            |                                |
                            |________________________________|


9 -- Декомпозиция --:

        Декомпозиция - это разбиение большой задачи на маленькие подзадачи, которые легче решить, или разбиение большого компонента на маленькие 
    компоненты, которые легче поддерживать и переиспользовать.

        Основное правило декомпозиции: каждый компонент должен быть независимым и не должен знать о внешнем мире. Чем слабо связанные компоненты
    будут делаться, тем масштабируемее будет приложение.

        К примеру, у нас есть компонент, который отвечает за отображение списка постов, и в этом компоненте мы хотим отобразить список постов, и
    для этого мы создаем дочерний компонент Post, который будет отвечать за отображение одного поста. И в этом дочернем компоненте мы хотим отобразить
    заголовок и текст поста, и для этого мы создаем дочерний компонент PostTitle, который будет отвечать за отображение заголовка поста, и дочерний
    компонент PostText, который будет отвечать за отображение текста поста.

        Таким образом, мы разбили большой компонент на маленькие компоненты, которые легче поддерживать и переиспользовать. Также мы соблюдаем
    основное правило декомпозиции: каждый компонент должен быть независимым и не должен знать о внешнем мире.

10 -- Слоты --:

        Слоты - это специальные элементы, которые позволяют нам передавать контент в дочерний компонент из родительского.
    Их синтаксис выглядит так: <slot></slot>. Все, что будет находиться между тегами <slot></slot> в родительском компоненте,
    будет передано в дочерний компонент.
        Если не использовать название для слота, то все, что будет находиться между тегами <slot></slot> в родительском компоненте,
    будет передано в дочерний компонент в слот по умолчанию. Если использовать название для слота, то все, что будет находиться между
    тегами <slot name="название_слота"></slot> в родительском компоненте, будет передано в дочерний компонент в слот с указанным названием.
        В дочернем компоненте слоты доступны в объекте $slots. В объекте $slots хранятся все слоты, которые были переданы в дочерний компонент.
    Если слот не был передан в дочерний компонент, то в объекте $slots будет пустой массив. Если слот был передан в дочерний компонент,
    то в объекте $slots будет массив, в котором будут храниться все переданные в дочерний компонент слоты.

11 -- modelValue --:

        modelValue - это входной параметр, который позволяет нам передавать в дочерний компонент значение модели. В дочернем компоненте мы можем
    изменять это значение, но мы не можем изменять значение модели в родительском компоненте. Если мы хотим изменить значение модели в родительском
    компоненте, то мы должны использовать событие update:modelValue. В дочернем компоненте мы должны вызвать событие update:modelValue и передать
    в него новое значение модели. В родительском компоненте мы должны подписаться на событие update:modelValue и в качестве аргумента принять новое
    значение модели.

        В примере ниже мы передаем в дочерний компонент Post значение модели post, и в дочернем компоненте мы можем изменять это значение, но мы не
    можем изменять значение модели post в родительском компоненте. Если мы хотим изменить значение модели post в родительском компоненте, то мы должны
    использовать событие update:modelValue. В дочернем компоненте мы должны вызвать событие update:modelValue и передать в него новое значение модели.
    В родительском компоненте мы должны подписаться на событие update:modelValue и в качестве аргумента принять новое значение модели.

    <template>
        <div>
            <h1>{{ post.title }}</h1>
            <p>{{ post.text }}</p>
            <button @click="updatePost">Обновить пост</button>
        </div>
    </template>

    <script>
        export default {
            name: 'Post',
            props: {
                modelValue: {
                    type: Object,
                    required: true
                }
            },
            data() {
                return {
                    post: this.modelValue
                }
            },
            methods: {
                updatePost() {
                    this.post.title = 'Новый заголовок'
                    this.post.text = 'Новый текст'
                    this.$emit('update:modelValue', this.post)
                }
            }
        }
    </script>

    <style scoped>
        h1 {
            color: red;
        }
    </style>

    




